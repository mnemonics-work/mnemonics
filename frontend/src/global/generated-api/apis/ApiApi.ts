/* tslint:disable */
/* eslint-disable */
/**
 * v2.0 Documentation
 * Swagger Specification
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Category,
    CategoryFromJSON,
    CategoryToJSON,
    Expression,
    ExpressionFromJSON,
    ExpressionToJSON,
    InlineResponse200,
    InlineResponse200FromJSON,
    InlineResponse200ToJSON,
    Mnemonic,
    MnemonicFromJSON,
    MnemonicToJSON,
    MnemonicType,
    MnemonicTypeFromJSON,
    MnemonicTypeToJSON,
    Tag,
    TagFromJSON,
    TagToJSON,
} from '../models';

export interface ApiCategoriesListRequest {
    ids?: Array<number>;
    parentTopicIsNull?: string;
}

export interface ApiCategoriesReadRequest {
    id: number;
}

export interface ApiCategoriesRelatedExpressionsRequest {
    id: number;
}

export interface ApiExpressionsCreateRequest {
    data: Expression;
}

export interface ApiExpressionsDeleteRequest {
    id: number;
}

export interface ApiExpressionsPartialUpdateRequest {
    id: number;
    data: Expression;
}

export interface ApiExpressionsReadRequest {
    id: number;
}

export interface ApiExpressionsRelatedCategoriesRequest {
    id: number;
}

export interface ApiExpressionsUpdateRequest {
    id: number;
    data: Expression;
}

export interface ApiMnemonicTypesCreateRequest {
    data: MnemonicType;
}

export interface ApiMnemonicTypesDeleteRequest {
    id: number;
}

export interface ApiMnemonicTypesPartialUpdateRequest {
    id: number;
    data: MnemonicType;
}

export interface ApiMnemonicTypesReadRequest {
    id: number;
}

export interface ApiMnemonicTypesUpdateRequest {
    id: number;
    data: MnemonicType;
}

export interface ApiMnemonicsCreateRequest {
    data: Mnemonic;
}

export interface ApiMnemonicsDeleteRequest {
    id: number;
}

export interface ApiMnemonicsListRequest {
    search?: string;
    tags?: Array<number>;
    types?: Array<number>;
    ids?: Array<number>;
    limit?: number;
    offset?: number;
}

export interface ApiMnemonicsPartialUpdateRequest {
    id: number;
    data: Mnemonic;
}

export interface ApiMnemonicsReadRequest {
    id: number;
}

export interface ApiMnemonicsUpdateRequest {
    id: number;
    data: Mnemonic;
}

export interface ApiTagsReadRequest {
    id: number;
}

/**
 * 
 */
export class ApiApi extends runtime.BaseAPI {

    /**
     */
    async apiCategoriesListRaw(requestParameters: ApiCategoriesListRequest): Promise<runtime.ApiResponse<Array<Category>>> {
        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.parentTopicIsNull !== undefined) {
            queryParameters['parent_topic_is_null'] = requestParameters.parentTopicIsNull;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/categories`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CategoryFromJSON));
    }

    /**
     */
    async apiCategoriesList(requestParameters: ApiCategoriesListRequest): Promise<Array<Category>> {
        const response = await this.apiCategoriesListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCategoriesReadRaw(requestParameters: ApiCategoriesReadRequest): Promise<runtime.ApiResponse<Category>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiCategoriesRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/categories/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CategoryFromJSON(jsonValue));
    }

    /**
     */
    async apiCategoriesRead(requestParameters: ApiCategoriesReadRequest): Promise<Category> {
        const response = await this.apiCategoriesReadRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCategoriesRelatedExpressionsRaw(requestParameters: ApiCategoriesRelatedExpressionsRequest): Promise<runtime.ApiResponse<Array<Expression>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiCategoriesRelatedExpressions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/categories/{id}/related_expressions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ExpressionFromJSON));
    }

    /**
     */
    async apiCategoriesRelatedExpressions(requestParameters: ApiCategoriesRelatedExpressionsRequest): Promise<Array<Expression>> {
        const response = await this.apiCategoriesRelatedExpressionsRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExpressionsCreateRaw(requestParameters: ApiExpressionsCreateRequest): Promise<runtime.ApiResponse<Expression>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiExpressionsCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExpressionToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExpressionFromJSON(jsonValue));
    }

    /**
     */
    async apiExpressionsCreate(requestParameters: ApiExpressionsCreateRequest): Promise<Expression> {
        const response = await this.apiExpressionsCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExpressionsDeleteRaw(requestParameters: ApiExpressionsDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExpressionsDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiExpressionsDelete(requestParameters: ApiExpressionsDeleteRequest): Promise<void> {
        await this.apiExpressionsDeleteRaw(requestParameters);
    }

    /**
     */
    async apiExpressionsListRaw(): Promise<runtime.ApiResponse<Array<Expression>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ExpressionFromJSON));
    }

    /**
     */
    async apiExpressionsList(): Promise<Array<Expression>> {
        const response = await this.apiExpressionsListRaw();
        return await response.value();
    }

    /**
     */
    async apiExpressionsPartialUpdateRaw(requestParameters: ApiExpressionsPartialUpdateRequest): Promise<runtime.ApiResponse<Expression>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExpressionsPartialUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiExpressionsPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ExpressionToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExpressionFromJSON(jsonValue));
    }

    /**
     */
    async apiExpressionsPartialUpdate(requestParameters: ApiExpressionsPartialUpdateRequest): Promise<Expression> {
        const response = await this.apiExpressionsPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExpressionsReadRaw(requestParameters: ApiExpressionsReadRequest): Promise<runtime.ApiResponse<Expression>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExpressionsRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExpressionFromJSON(jsonValue));
    }

    /**
     */
    async apiExpressionsRead(requestParameters: ApiExpressionsReadRequest): Promise<Expression> {
        const response = await this.apiExpressionsReadRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExpressionsRelatedCategoriesRaw(requestParameters: ApiExpressionsRelatedCategoriesRequest): Promise<runtime.ApiResponse<Array<Category>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExpressionsRelatedCategories.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions/{id}/related_categories`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CategoryFromJSON));
    }

    /**
     */
    async apiExpressionsRelatedCategories(requestParameters: ApiExpressionsRelatedCategoriesRequest): Promise<Array<Category>> {
        const response = await this.apiExpressionsRelatedCategoriesRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExpressionsUpdateRaw(requestParameters: ApiExpressionsUpdateRequest): Promise<runtime.ApiResponse<Expression>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExpressionsUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiExpressionsUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ExpressionToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExpressionFromJSON(jsonValue));
    }

    /**
     */
    async apiExpressionsUpdate(requestParameters: ApiExpressionsUpdateRequest): Promise<Expression> {
        const response = await this.apiExpressionsUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicTypesCreateRaw(requestParameters: ApiMnemonicTypesCreateRequest): Promise<runtime.ApiResponse<MnemonicType>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiMnemonicTypesCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonicTypes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MnemonicTypeToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MnemonicTypeFromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicTypesCreate(requestParameters: ApiMnemonicTypesCreateRequest): Promise<MnemonicType> {
        const response = await this.apiMnemonicTypesCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicTypesDeleteRaw(requestParameters: ApiMnemonicTypesDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMnemonicTypesDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonicTypes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiMnemonicTypesDelete(requestParameters: ApiMnemonicTypesDeleteRequest): Promise<void> {
        await this.apiMnemonicTypesDeleteRaw(requestParameters);
    }

    /**
     */
    async apiMnemonicTypesListRaw(): Promise<runtime.ApiResponse<Array<MnemonicType>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonicTypes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MnemonicTypeFromJSON));
    }

    /**
     */
    async apiMnemonicTypesList(): Promise<Array<MnemonicType>> {
        const response = await this.apiMnemonicTypesListRaw();
        return await response.value();
    }

    /**
     */
    async apiMnemonicTypesPartialUpdateRaw(requestParameters: ApiMnemonicTypesPartialUpdateRequest): Promise<runtime.ApiResponse<MnemonicType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMnemonicTypesPartialUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiMnemonicTypesPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonicTypes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: MnemonicTypeToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MnemonicTypeFromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicTypesPartialUpdate(requestParameters: ApiMnemonicTypesPartialUpdateRequest): Promise<MnemonicType> {
        const response = await this.apiMnemonicTypesPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicTypesReadRaw(requestParameters: ApiMnemonicTypesReadRequest): Promise<runtime.ApiResponse<MnemonicType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMnemonicTypesRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonicTypes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MnemonicTypeFromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicTypesRead(requestParameters: ApiMnemonicTypesReadRequest): Promise<MnemonicType> {
        const response = await this.apiMnemonicTypesReadRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicTypesUpdateRaw(requestParameters: ApiMnemonicTypesUpdateRequest): Promise<runtime.ApiResponse<MnemonicType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMnemonicTypesUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiMnemonicTypesUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonicTypes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MnemonicTypeToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MnemonicTypeFromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicTypesUpdate(requestParameters: ApiMnemonicTypesUpdateRequest): Promise<MnemonicType> {
        const response = await this.apiMnemonicTypesUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicsCreateRaw(requestParameters: ApiMnemonicsCreateRequest): Promise<runtime.ApiResponse<Mnemonic>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiMnemonicsCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonics`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MnemonicToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MnemonicFromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicsCreate(requestParameters: ApiMnemonicsCreateRequest): Promise<Mnemonic> {
        const response = await this.apiMnemonicsCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicsDeleteRaw(requestParameters: ApiMnemonicsDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMnemonicsDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonics/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiMnemonicsDelete(requestParameters: ApiMnemonicsDeleteRequest): Promise<void> {
        await this.apiMnemonicsDeleteRaw(requestParameters);
    }

    /**
     */
    async apiMnemonicsListRaw(requestParameters: ApiMnemonicsListRequest): Promise<runtime.ApiResponse<InlineResponse200>> {
        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.tags) {
            queryParameters['tags'] = requestParameters.tags.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.types) {
            queryParameters['types'] = requestParameters.types.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonics`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse200FromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicsList(requestParameters: ApiMnemonicsListRequest): Promise<InlineResponse200> {
        const response = await this.apiMnemonicsListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicsPartialUpdateRaw(requestParameters: ApiMnemonicsPartialUpdateRequest): Promise<runtime.ApiResponse<Mnemonic>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMnemonicsPartialUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiMnemonicsPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonics/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: MnemonicToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MnemonicFromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicsPartialUpdate(requestParameters: ApiMnemonicsPartialUpdateRequest): Promise<Mnemonic> {
        const response = await this.apiMnemonicsPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicsReadRaw(requestParameters: ApiMnemonicsReadRequest): Promise<runtime.ApiResponse<Mnemonic>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMnemonicsRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonics/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MnemonicFromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicsRead(requestParameters: ApiMnemonicsReadRequest): Promise<Mnemonic> {
        const response = await this.apiMnemonicsReadRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicsUpdateRaw(requestParameters: ApiMnemonicsUpdateRequest): Promise<runtime.ApiResponse<Mnemonic>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMnemonicsUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiMnemonicsUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonics/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MnemonicToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MnemonicFromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicsUpdate(requestParameters: ApiMnemonicsUpdateRequest): Promise<Mnemonic> {
        const response = await this.apiMnemonicsUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiTagsListRaw(): Promise<runtime.ApiResponse<Array<Tag>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/tags`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TagFromJSON));
    }

    /**
     */
    async apiTagsList(): Promise<Array<Tag>> {
        const response = await this.apiTagsListRaw();
        return await response.value();
    }

    /**
     */
    async apiTagsReadRaw(requestParameters: ApiTagsReadRequest): Promise<runtime.ApiResponse<Tag>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiTagsRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/tags/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TagFromJSON(jsonValue));
    }

    /**
     */
    async apiTagsRead(requestParameters: ApiTagsReadRequest): Promise<Tag> {
        const response = await this.apiTagsReadRaw(requestParameters);
        return await response.value();
    }

}
