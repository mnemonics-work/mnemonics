/* tslint:disable */
/* eslint-disable */
/**
 * v2.0 Documentation
 * Swagger Specification
 *
 * The version of the OpenAPI document: v2
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AuthToken,
    AuthTokenFromJSON,
    AuthTokenToJSON,
    Category,
    CategoryFromJSON,
    CategoryToJSON,
    Expression,
    ExpressionFromJSON,
    ExpressionToJSON,
    ExpressionCreate,
    ExpressionCreateFromJSON,
    ExpressionCreateToJSON,
    ExpressionUpdate,
    ExpressionUpdateFromJSON,
    ExpressionUpdateToJSON,
    GoogleSocialAuth,
    GoogleSocialAuthFromJSON,
    GoogleSocialAuthToJSON,
    InlineResponse200,
    InlineResponse200FromJSON,
    InlineResponse200ToJSON,
    IsAuthorExpression,
    IsAuthorExpressionFromJSON,
    IsAuthorExpressionToJSON,
    IsAuthorMnemonic,
    IsAuthorMnemonicFromJSON,
    IsAuthorMnemonicToJSON,
    Mnemonic,
    MnemonicFromJSON,
    MnemonicToJSON,
    MnemonicCreateUpdate,
    MnemonicCreateUpdateFromJSON,
    MnemonicCreateUpdateToJSON,
    MnemonicType,
    MnemonicTypeFromJSON,
    MnemonicTypeToJSON,
    Register,
    RegisterFromJSON,
    RegisterToJSON,
    RelatedMnemonicsExpression,
    RelatedMnemonicsExpressionFromJSON,
    RelatedMnemonicsExpressionToJSON,
    Tag,
    TagFromJSON,
    TagToJSON,
    Token,
    TokenFromJSON,
    TokenToJSON,
} from '../models';

export interface ApiAuthGoogleRequest {
    data: GoogleSocialAuth;
}

export interface ApiAuthLoginRequest {
    data: AuthToken;
}

export interface ApiAuthRegisterRequest {
    data: Register;
}

export interface ApiCategoriesListRequest {
    ids?: Array<number>;
    parentTopicIsNull?: string;
}

export interface ApiCategoriesReadRequest {
    id: number;
}

export interface ApiCategoriesRelatedExpressionsRequest {
    id: number;
}

export interface ApiExpressionsAddRelatedMnemonicsRequest {
    id: number;
    data: RelatedMnemonicsExpression;
}

export interface ApiExpressionsCreateRequest {
    data: ExpressionCreate;
}

export interface ApiExpressionsDeleteRequest {
    id: number;
}

export interface ApiExpressionsIsAuthorRequest {
    id: number;
}

export interface ApiExpressionsPartialUpdateRequest {
    id: number;
    data: Expression;
}

export interface ApiExpressionsReadRequest {
    id: number;
}

export interface ApiExpressionsRelatedCategoriesRequest {
    id: number;
}

export interface ApiExpressionsUpdateRequest {
    id: number;
    data: ExpressionUpdate;
}

export interface ApiMnemonicTypesReadRequest {
    id: number;
}

export interface ApiMnemonicsDeleteRequest {
    id: number;
}

export interface ApiMnemonicsIsAuthorRequest {
    id: number;
}

export interface ApiMnemonicsListRequest {
    search?: string;
    tags?: Array<number>;
    types?: Array<number>;
    ids?: Array<number>;
    limit?: number;
    offset?: number;
}

export interface ApiMnemonicsPartialUpdateRequest {
    id: number;
    data: Mnemonic;
}

export interface ApiMnemonicsReadRequest {
    id: number;
}

export interface ApiMnemonicsUpdateRequest {
    id: number;
    data: MnemonicCreateUpdate;
}

export interface ApiTagsReadRequest {
    id: number;
}

/**
 * 
 */
export class ApiApi extends runtime.BaseAPI {

    /**
     */
    async apiAuthGoogleRaw(requestParameters: ApiAuthGoogleRequest): Promise<runtime.ApiResponse<Token>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiAuthGoogle.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/auth/google`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GoogleSocialAuthToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
    }

    /**
     */
    async apiAuthGoogle(requestParameters: ApiAuthGoogleRequest): Promise<Token> {
        const response = await this.apiAuthGoogleRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiAuthLoginRaw(requestParameters: ApiAuthLoginRequest): Promise<runtime.ApiResponse<Token>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiAuthLogin.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/auth/login`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AuthTokenToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
    }

    /**
     */
    async apiAuthLogin(requestParameters: ApiAuthLoginRequest): Promise<Token> {
        const response = await this.apiAuthLoginRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiAuthRegisterRaw(requestParameters: ApiAuthRegisterRequest): Promise<runtime.ApiResponse<Token>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiAuthRegister.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/auth/register`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RegisterToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
    }

    /**
     */
    async apiAuthRegister(requestParameters: ApiAuthRegisterRequest): Promise<Token> {
        const response = await this.apiAuthRegisterRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCategoriesListRaw(requestParameters: ApiCategoriesListRequest): Promise<runtime.ApiResponse<Array<Category>>> {
        const queryParameters: any = {};

        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.parentTopicIsNull !== undefined) {
            queryParameters['parent_topic_is_null'] = requestParameters.parentTopicIsNull;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/categories`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CategoryFromJSON));
    }

    /**
     */
    async apiCategoriesList(requestParameters: ApiCategoriesListRequest): Promise<Array<Category>> {
        const response = await this.apiCategoriesListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCategoriesReadRaw(requestParameters: ApiCategoriesReadRequest): Promise<runtime.ApiResponse<Category>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiCategoriesRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/categories/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CategoryFromJSON(jsonValue));
    }

    /**
     */
    async apiCategoriesRead(requestParameters: ApiCategoriesReadRequest): Promise<Category> {
        const response = await this.apiCategoriesReadRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCategoriesRelatedExpressionsRaw(requestParameters: ApiCategoriesRelatedExpressionsRequest): Promise<runtime.ApiResponse<Array<Expression>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiCategoriesRelatedExpressions.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/categories/{id}/related_expressions`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ExpressionFromJSON));
    }

    /**
     */
    async apiCategoriesRelatedExpressions(requestParameters: ApiCategoriesRelatedExpressionsRequest): Promise<Array<Expression>> {
        const response = await this.apiCategoriesRelatedExpressionsRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExpressionsAddRelatedMnemonicsRaw(requestParameters: ApiExpressionsAddRelatedMnemonicsRequest): Promise<runtime.ApiResponse<Expression>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExpressionsAddRelatedMnemonics.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiExpressionsAddRelatedMnemonics.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions/{id}/add_related_mnemonics`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RelatedMnemonicsExpressionToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExpressionFromJSON(jsonValue));
    }

    /**
     */
    async apiExpressionsAddRelatedMnemonics(requestParameters: ApiExpressionsAddRelatedMnemonicsRequest): Promise<Expression> {
        const response = await this.apiExpressionsAddRelatedMnemonicsRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExpressionsCreateRaw(requestParameters: ApiExpressionsCreateRequest): Promise<runtime.ApiResponse<Expression>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiExpressionsCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExpressionCreateToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExpressionFromJSON(jsonValue));
    }

    /**
     */
    async apiExpressionsCreate(requestParameters: ApiExpressionsCreateRequest): Promise<Expression> {
        const response = await this.apiExpressionsCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExpressionsDeleteRaw(requestParameters: ApiExpressionsDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExpressionsDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiExpressionsDelete(requestParameters: ApiExpressionsDeleteRequest): Promise<void> {
        await this.apiExpressionsDeleteRaw(requestParameters);
    }

    /**
     */
    async apiExpressionsIsAuthorRaw(requestParameters: ApiExpressionsIsAuthorRequest): Promise<runtime.ApiResponse<IsAuthorExpression>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExpressionsIsAuthor.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions/{id}/is_author`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IsAuthorExpressionFromJSON(jsonValue));
    }

    /**
     */
    async apiExpressionsIsAuthor(requestParameters: ApiExpressionsIsAuthorRequest): Promise<IsAuthorExpression> {
        const response = await this.apiExpressionsIsAuthorRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExpressionsListRaw(): Promise<runtime.ApiResponse<Array<Expression>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ExpressionFromJSON));
    }

    /**
     */
    async apiExpressionsList(): Promise<Array<Expression>> {
        const response = await this.apiExpressionsListRaw();
        return await response.value();
    }

    /**
     */
    async apiExpressionsPartialUpdateRaw(requestParameters: ApiExpressionsPartialUpdateRequest): Promise<runtime.ApiResponse<Expression>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExpressionsPartialUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiExpressionsPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ExpressionToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExpressionFromJSON(jsonValue));
    }

    /**
     */
    async apiExpressionsPartialUpdate(requestParameters: ApiExpressionsPartialUpdateRequest): Promise<Expression> {
        const response = await this.apiExpressionsPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExpressionsReadRaw(requestParameters: ApiExpressionsReadRequest): Promise<runtime.ApiResponse<Expression>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExpressionsRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExpressionFromJSON(jsonValue));
    }

    /**
     */
    async apiExpressionsRead(requestParameters: ApiExpressionsReadRequest): Promise<Expression> {
        const response = await this.apiExpressionsReadRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExpressionsRelatedCategoriesRaw(requestParameters: ApiExpressionsRelatedCategoriesRequest): Promise<runtime.ApiResponse<Array<Category>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExpressionsRelatedCategories.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions/{id}/related_categories`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CategoryFromJSON));
    }

    /**
     */
    async apiExpressionsRelatedCategories(requestParameters: ApiExpressionsRelatedCategoriesRequest): Promise<Array<Category>> {
        const response = await this.apiExpressionsRelatedCategoriesRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExpressionsUpdateRaw(requestParameters: ApiExpressionsUpdateRequest): Promise<runtime.ApiResponse<Expression>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExpressionsUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiExpressionsUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/expressions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ExpressionUpdateToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExpressionFromJSON(jsonValue));
    }

    /**
     */
    async apiExpressionsUpdate(requestParameters: ApiExpressionsUpdateRequest): Promise<Expression> {
        const response = await this.apiExpressionsUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicTypesListRaw(): Promise<runtime.ApiResponse<Array<MnemonicType>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonicTypes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MnemonicTypeFromJSON));
    }

    /**
     */
    async apiMnemonicTypesList(): Promise<Array<MnemonicType>> {
        const response = await this.apiMnemonicTypesListRaw();
        return await response.value();
    }

    /**
     */
    async apiMnemonicTypesReadRaw(requestParameters: ApiMnemonicTypesReadRequest): Promise<runtime.ApiResponse<MnemonicType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMnemonicTypesRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonicTypes/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MnemonicTypeFromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicTypesRead(requestParameters: ApiMnemonicTypesReadRequest): Promise<MnemonicType> {
        const response = await this.apiMnemonicTypesReadRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicsDeleteRaw(requestParameters: ApiMnemonicsDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMnemonicsDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonics/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiMnemonicsDelete(requestParameters: ApiMnemonicsDeleteRequest): Promise<void> {
        await this.apiMnemonicsDeleteRaw(requestParameters);
    }

    /**
     */
    async apiMnemonicsIsAuthorRaw(requestParameters: ApiMnemonicsIsAuthorRequest): Promise<runtime.ApiResponse<IsAuthorMnemonic>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMnemonicsIsAuthor.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonics/{id}/is_author`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IsAuthorMnemonicFromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicsIsAuthor(requestParameters: ApiMnemonicsIsAuthorRequest): Promise<IsAuthorMnemonic> {
        const response = await this.apiMnemonicsIsAuthorRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicsListRaw(requestParameters: ApiMnemonicsListRequest): Promise<runtime.ApiResponse<InlineResponse200>> {
        const queryParameters: any = {};

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.tags) {
            queryParameters['tags'] = requestParameters.tags.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.types) {
            queryParameters['types'] = requestParameters.types.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.ids) {
            queryParameters['ids'] = requestParameters.ids.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonics`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InlineResponse200FromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicsList(requestParameters: ApiMnemonicsListRequest): Promise<InlineResponse200> {
        const response = await this.apiMnemonicsListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicsPartialUpdateRaw(requestParameters: ApiMnemonicsPartialUpdateRequest): Promise<runtime.ApiResponse<Mnemonic>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMnemonicsPartialUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiMnemonicsPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonics/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: MnemonicToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MnemonicFromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicsPartialUpdate(requestParameters: ApiMnemonicsPartialUpdateRequest): Promise<Mnemonic> {
        const response = await this.apiMnemonicsPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicsReadRaw(requestParameters: ApiMnemonicsReadRequest): Promise<runtime.ApiResponse<Mnemonic>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMnemonicsRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonics/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MnemonicFromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicsRead(requestParameters: ApiMnemonicsReadRequest): Promise<Mnemonic> {
        const response = await this.apiMnemonicsReadRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiMnemonicsUpdateRaw(requestParameters: ApiMnemonicsUpdateRequest): Promise<runtime.ApiResponse<Mnemonic>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMnemonicsUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling apiMnemonicsUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/mnemonics/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MnemonicCreateUpdateToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MnemonicFromJSON(jsonValue));
    }

    /**
     */
    async apiMnemonicsUpdate(requestParameters: ApiMnemonicsUpdateRequest): Promise<Mnemonic> {
        const response = await this.apiMnemonicsUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiTagsListRaw(): Promise<runtime.ApiResponse<Array<Tag>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/tags`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TagFromJSON));
    }

    /**
     */
    async apiTagsList(): Promise<Array<Tag>> {
        const response = await this.apiTagsListRaw();
        return await response.value();
    }

    /**
     */
    async apiTagsReadRaw(requestParameters: ApiTagsReadRequest): Promise<runtime.ApiResponse<Tag>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiTagsRead.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/tags/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TagFromJSON(jsonValue));
    }

    /**
     */
    async apiTagsRead(requestParameters: ApiTagsReadRequest): Promise<Tag> {
        const response = await this.apiTagsReadRaw(requestParameters);
        return await response.value();
    }

}
